"""
FastMCP server exposing create_business_rule via HTTP/SSE.
Run: python sn_mcp_tools.py
"""

import os, sys, httpx, asyncio 
from typing import Optional, List, Dict, Any
from fastmcp import FastMCP
from dotenv import load_dotenv, dotenv_values



mcp = FastMCP("sn_mcp_tools")

 # Load environment variables from .env file
load_dotenv()
# ----- ServiceNow credentials -----
SN_URL  = os.getenv("SERVICENOW_URL", "").rstrip("/")
SN_USER = os.getenv("SERVICENOW_USER", "")
SN_PASS = os.getenv("SERVICENOW_PASS", "")

# Debug credentials loading
print(f"DEBUG: SN_URL={SN_URL}", file=sys.stderr)
print(f"DEBUG: SN_USER={SN_USER}", file=sys.stderr)




@mcp.tool()
async def create_business_rule(
        name: str,
        table: str,
        script: str,
        when: str = "before",
        active: bool = True,
        description: Optional[str] = None,
        action_insert: bool = True,
        action_update: bool = True,
        action_delete: bool = False,
        action_query: bool = False,
        advanced: bool = True,
        order: int = 100,
        abort_action: bool = False
) -> str:
    """Create/replace a Business Rule and return its sys_id."""
    payload = {
        "name": name,
        "collection": table,
        "when": when,
        "active": str(active).lower(),
        "script": script,
        "description": description or f"Generated by FastMCP on {table}",
        "action_insert": str(action_insert).lower(),
        "action_update": str(action_update).lower(),
        "action_delete": str(action_delete).lower(),
        "action_query": str(action_query).lower(),
        "advanced": str(advanced).lower(),
        "order": str(order),
        "abort_action": str(abort_action).lower()
    }
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.post(f"{SN_URL}/api/now/table/sys_script", json=payload, headers=headers)
        # Log everything for debugging
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)

        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def list_business_rules(
        query: str,
        table: Optional[str] = None,
        limit: int = 5
) -> List[Dict[str, Any]]:
    """List top Business Rules based on query and optional table filter, up to the limit."""
    # Validate credentials
    if not SN_URL or not SN_USER or not SN_PASS:
        raise RuntimeError(f"Missing ServiceNow credentials: URL={bool(SN_URL)}, USER={bool(SN_USER)}, PASS={bool(SN_PASS)}")
    # Construct query params
    params = {
        "sysparm_limit": str(limit),
        "sysparm_display_value": "true",
        "sysparm_exclude_reference_link": "true",
        "sysparm_query": f"nameLIKE{query}"
    }
    
    # Add table filter if specified
    if table:
        params["sysparm_query"] += f"^collection={table}"
    
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script", params=params, headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            results = r.json()["result"]
            # Return only the relevant fields
            return [{
                "sys_id": rule.get("sys_id", ""),
                "name": rule.get("name", ""),
                "table": rule.get("collection", ""),
                "when": rule.get("when", ""),
                "active": rule.get("active", ""),
                "description": rule.get("description", ""),
                "action_insert": rule.get("action_insert", ""),
                "action_update": rule.get("action_update", ""),
                "action_delete": rule.get("action_delete", ""),
                "action_query": rule.get("action_query", ""),
                "advanced": rule.get("advanced", ""),
                "order": rule.get("order", ""),
                "abort_action": rule.get("abort_action", "")
            } for rule in results]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def update_business_rule(
        sys_id: str,
        script: str,
        name: Optional[str] = None,
        table: Optional[str] = None,
        when: Optional[str] = None,
        active: Optional[bool] = None,
        description: Optional[str] = None,
        action_insert: Optional[bool] = None,
        action_update: Optional[bool] = None,
        action_delete: Optional[bool] = None,
        action_query: Optional[bool] = None,
        advanced: Optional[bool] = None,
        order: Optional[int] = None,
        abort_action: Optional[bool] = None
) -> str:
    """Update an existing Business Rule by sys_id and return its sys_id."""
    # Build payload with only provided fields
    payload = {"script": script}
    if name:
        payload["name"] = name
    if table:
        payload["collection"] = table
    if when:
        payload["when"] = when
    if active is not None:
        payload["active"] = str(active).lower()
    if description:
        payload["description"] = description
    if action_insert is not None:
        payload["action_insert"] = str(action_insert).lower()
    if action_update is not None:
        payload["action_update"] = str(action_update).lower()
    if action_delete is not None:
        payload["action_delete"] = str(action_delete).lower()
    if action_query is not None:
        payload["action_query"] = str(action_query).lower()
    if advanced is not None:
        payload["advanced"] = str(advanced).lower()
    if order is not None:
        payload["order"] = str(order)
    if abort_action is not None:
        payload["abort_action"] = str(abort_action).lower()
    
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.put(f"{SN_URL}/api/now/table/sys_script/{sys_id}", json=payload, headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def create_client_script(
        name: str,
        table: str,
        script: str,
        type: str = "onLoad",
        active: bool = True,
        description: Optional[str] = None,
        field: Optional[str] = None,
        global_scope: bool = True,
        isolate_script: bool = True,
        order: int = 100
) -> str:
    """Create/replace a Client Script and return its sys_id."""
    payload = {
        "name": name,
        "table": table,
        "script": script,
        "type": type,
        "active": str(active).lower(),
        "description": description or f"Generated by FastMCP on {table}",
        "global": str(global_scope).lower(),
        "isolate_script": str(isolate_script).lower(),
        "order": str(order)
    }
    
    if field:
        payload["field"] = field
    
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.post(f"{SN_URL}/api/now/table/sys_script_client", json=payload, headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def list_client_scripts(
        query: str,
        table: Optional[str] = None,
        limit: int = 5
) -> List[Dict[str, Any]]:
    """List top Client Scripts based on query and optional table filter, up to the limit."""
    # Construct query params
    params = {
        "sysparm_limit": str(limit),
        "sysparm_display_value": "true",
        "sysparm_exclude_reference_link": "true",
        "sysparm_query": f"nameLIKE{query}"
    }
    
    # Add table filter if specified
    if table:
        params["sysparm_query"] += f"^table={table}"
    
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script_client", params=params, headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            results = r.json()["result"]
            # Return only the relevant fields
            return [{
                "sys_id": script.get("sys_id", ""),
                "name": script.get("name", ""),
                "table": script.get("table", ""),
                "type": script.get("type", ""),
                "active": script.get("active", ""),
                "description": script.get("description", ""),
                "field": script.get("field", ""),
                "global": script.get("global", ""),
                "isolate_script": script.get("isolate_script", ""),
                "order": script.get("order", "")
            } for script in results]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def update_client_script(
        sys_id: str,
        script: str,
        name: Optional[str] = None,
        table: Optional[str] = None,
        type: Optional[str] = None,
        active: Optional[bool] = None,
        description: Optional[str] = None,
        field: Optional[str] = None,
        global_scope: Optional[bool] = None,
        isolate_script: Optional[bool] = None,
        order: Optional[int] = None
) -> str:
    """Update an existing Client Script by sys_id and return its sys_id."""
    # Build payload with only provided fields
    payload = {"script": script}
    if name:
        payload["name"] = name
    if table:
        payload["table"] = table
    if type:
        payload["type"] = type
    if active is not None:
        payload["active"] = str(active).lower()
    if description:
        payload["description"] = description
    if field:
        payload["field"] = field
    if global_scope is not None:
        payload["global"] = str(global_scope).lower()
    if isolate_script is not None:
        payload["isolate_script"] = str(isolate_script).lower()
    if order is not None:
        payload["order"] = str(order)
    
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.put(f"{SN_URL}/api/now/table/sys_script_client/{sys_id}", json=payload, headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def get_business_rule(sys_id: str) -> Dict[str, Any]:
    """Get a specific Business Rule by sys_id."""
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script/{sys_id}", headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            result = r.json()["result"]
            return {
                "sys_id": result.get("sys_id", ""),
                "name": result.get("name", ""),
                "table": result.get("collection", ""),
                "when": result.get("when", ""),
                "active": result.get("active", ""),
                "description": result.get("description", ""),
                "script": result.get("script", ""),
                "action_insert": result.get("action_insert", ""),
                "action_update": result.get("action_update", ""),
                "action_delete": result.get("action_delete", ""),
                "action_query": result.get("action_query", ""),
                "advanced": result.get("advanced", ""),
                "order": result.get("order", ""),
                "abort_action": result.get("abort_action", "")
            }
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def get_client_script(sys_id: str) -> Dict[str, Any]:
    """Get a specific Client Script by sys_id."""
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script_client/{sys_id}", headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            result = r.json()["result"]
            return {
                "sys_id": result.get("sys_id", ""),
                "name": result.get("name", ""),
                "table": result.get("table", ""),
                "type": result.get("type", ""),
                "active": result.get("active", ""),
                "description": result.get("description", ""),
                "script": result.get("script", ""),
                "field": result.get("field", ""),
                "global": result.get("global", ""),
                "isolate_script": result.get("isolate_script", ""),
                "order": result.get("order", "")
            }
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def create_script_include(
        name: str,
        script: str,
        active: bool = True,
        description: Optional[str] = None,
        api_name: Optional[str] = None,
        access: str = "package_private",
        client_callable: bool = False
) -> str:
    """Create/replace a Script Include and return its sys_id."""
    payload = {
        "name": name,
        "script": script,
        "active": str(active).lower(),
        "description": description or f"Generated by FastMCP",
        "api_name": api_name or f"global.{name}",
        "access": access,
        "client_callable": str(client_callable).lower()
    }
    
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.post(f"{SN_URL}/api/now/table/sys_script_include", json=payload, headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def update_script_include(
        sys_id: str,
        script: str,
        name: Optional[str] = None,
        active: Optional[bool] = None,
        description: Optional[str] = None,
        api_name: Optional[str] = None,
        access: Optional[str] = None,
        client_callable: Optional[bool] = None
) -> str:
    """Update an existing Script Include by sys_id and return its sys_id."""
    # Build payload with only provided fields
    payload = {"script": script}
    if name:
        payload["name"] = name
    if active is not None:
        payload["active"] = str(active).lower()
    if description:
        payload["description"] = description
    if api_name:
        payload["api_name"] = api_name
    if access:
        payload["access"] = access
    if client_callable is not None:
        payload["client_callable"] = str(client_callable).lower()
    
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.put(f"{SN_URL}/api/now/table/sys_script_include/{sys_id}", json=payload, headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            return r.json()["result"]["sys_id"]
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

@mcp.tool()
async def get_script_include(sys_id: str) -> Dict[str, Any]:
    """Get a specific Script Include by sys_id."""
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    async with httpx.AsyncClient(auth=(SN_USER, SN_PASS)) as c:
        r = await c.get(f"{SN_URL}/api/now/table/sys_script_include/{sys_id}", headers=headers)
        dbg = f"SN status={r.status_code} CT={r.headers.get('content-type')} body={r.text[:200]}"
        print(dbg, file=sys.stderr)
        
        try:
            r.raise_for_status()
            result = r.json()["result"]
            return {
                "sys_id": result.get("sys_id", ""),
                "name": result.get("name", ""),
                "active": result.get("active", ""),
                "description": result.get("description", ""),
                "script": result.get("script", ""),
                "api_name": result.get("api_name", ""),
                "access": result.get("access", ""),
                "client_callable": result.get("client_callable", "")
            }
        except httpx.HTTPStatusError as e:
            raise RuntimeError(f"ServiceNow HTTP error {r.status_code}: {r.text}") from e
        except ValueError:
            raise RuntimeError(f"Non-JSON response from ServiceNow: {dbg}")

# ---------- launch on HTTP/SSE transport ----------
if __name__ == "__main__":
   
   
    asyncio.run(mcp.run(transport="http",host="127.0.0.1", port=9123, log_level="info"))
